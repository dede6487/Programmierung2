\documentclass[11pt]{article}

%Laenderspezifische Einstellungen bzgl. Rechtschreibung, Sonderzeichen und Kodierung
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{titlesec}
\usepackage{graphicx}

\usepackage{listings}
\usepackage{color}
\definecolor{light-gray}{gray}{0.85}
\lstset{
numbers=left,
breaklines=true,
backgroundcolor=\color{light-gray},
tabsize=2,
}

\usepackage[
	a4paper,
	top = 2cm,
	bottom = 2 cm,
	left = 2cm,
	right = 2cm,
	headheight = 15pt,
	includeheadfoot
	]{geometry}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[english]{varioref}
\usepackage{hyperref}

\fancypagestyle{fancy}{
	\fancyhead[R]{Seite \thepage}
	\fancyhead[L]{\leftmark}
	\renewcommand{\headrulewidth}{1.25pt}

	\fancyfoot[L]{\tiny{Programming 2 - Assignment 1, created: \today}}
	\fancyfoot[R]{\tiny{ Felix Dreßler (k12105003)}}
	\cfoot{}
	\renewcommand{\footrulewidth}{1.25pt}
}

\setlength{\headsep}{10mm}
\setlength{\footskip}{10mm}

\setlength{\parindent}{0mm}
\setlength{\parskip}{1.1ex plus0.25ex minus0.25ex}
\setlength{\tabcolsep}{0.2cm} % for the horizontal padding

\pagestyle{fancy}

\begin{document}

	\section{Programming 1 - First Assignment}	
	
		\begin{lstlisting}
//**********************************************************
//
//**********************************************************


#include <iostream>
#include <cstdlib>
#include <cmath>

#include "Drawing.h"

#if defined(_WIN32) || defined (_WIN64)
#include <windows.h>
#else
#include <time.h>
static void Sleep(int ms)
{
	struct timespec ts;
	ts.tv_sec = ms / 1000;
	ts.tv_nsec = (ms % 1000) * 1000000;
	nanosleep(&ts, NULL);
}
#endif

using namespace std;
using namespace compsys;

#include  <string>	//defines the getline() function
#include <fstream>
#include "Auxiliary.h"

int W = 640;	//W,H are the width and the height of the created window
int H = 480;

int S = 40;		//time between the frame-updates - sleep
int F = 200;	//number of updates that are performed by the program

//**********************************************************
// struct "Atom"
// 
// defines the data structure for an Atom
// Atoms hold the values:
// c ... colour
// r ... radius
// vx ... velocity in x
// vy ... velocity in y
// x ... x-value for position
// y ... y-value for position
// 
//**********************************************************

typedef struct Atom
{
	int c;
	int r;
	int vx;
	int vy;
	int x;
	int y;
};

//**********************************************************
// Funtion "random"
// 
// input: two int numbers which define the lower and the upper
// limits of the outputted random number
// 
// output: a random number in between the given limits
// including the limits
// 
//**********************************************************

int random(int llimit, int ulimit) {
	
	return (rand() % (ulimit - llimit + 1)) + llimit;
}

//**********************************************************
//	Function "number"
//	
//	creates Atoms with their initial Values as stated above
//	N Atoms will be created with random colour, random size and
//	random velocity at a random position.
//
//**********************************************************

double number(int argc, const char* argv[]) {
	int n = 3;
	
	if (argc == 2)
	{
		ifstream Input{ argv[1] };
		if (!Input) 
		{
			cout << "Error: check Input file (numbers)" << endl;
			return -1;
		}
		
		Input >> n;
		Input.close();
	}
	
	cout << "the number of Atoms is: " << n << endl;
	
	return n;
}

//**********************************************************
//
//**********************************************************

void init(int n, Atom Atom[], int argc, const char* argv[]) {
	
	if (argc == 2)
	{
		ifstream Input{ argv[1] };
		if (!Input) {
			cout << "Error: check Input file (init)" << endl;
			return;
		}
		
		while (Input)
		{
			int n;
			Input >> n;
			for (int j = 0; j < n; j++)
			{
				Input >> Atom[j].c;
				Input >> Atom[j].r;
				Input >> Atom[j].x;
				Input >> Atom[j].y;
				Input >> Atom[j].vx;
				Input >> Atom[j].vy;
				
				cout << "Atom " << j + 1 << " has the following values assigned:" << endl;
				cout << "Color" << j + 1 << " is      " << Atom[j].c << endl;
				cout << "Radius" << j + 1 << " is     " << Atom[j].r << endl;
				cout << "x Pos." << j + 1 << " is     " << Atom[j].x << endl;
				cout << "y Pos." << j + 1 << " is     " << Atom[j].y << endl;
				cout << "vx" << j + 1 << " is         " << Atom[j].vx << endl;
				cout << "vy" << j + 1 << " is         " << Atom[j].vy << endl;
			}
		}
		
		Input.close();
	}
	else if(argc == 1) {
		srand(time(0));
		for (int j = 0; j < n; j++) {
			Atom[j].c = random(000, 0xFFFFFF);
			Atom[j].r = random(20, 40);
			Atom[j].vx = random(5, 25);
			Atom[j].vy = random(5, 25);
			Atom[j].x = random(Atom[j].r, W - Atom[j].r);
			Atom[j].y = random(Atom[j].r, H - Atom[j].r);
			
			//the following function should check, if Atoms were to overlap
			
			bool valid=true;
			
			for (int l = 0; l <= j; l++) {
				int m = 0;
				if (sqrt(pow(Atom[j].x - Atom[l].x, 2) + pow(Atom[j].y - Atom[l].y, 2)) < Atom[j].r + Atom[l].r && j != l && valid)
				{
					Atom[j].x = random(Atom[j].r, W - Atom[j].r);
					Atom[j].y = random(Atom[j].r, H - Atom[j].r);
					
					m++;
					
					if (m >= 2) {
						valid = false;
					}
				}
				else if(!valid){
					cout << "Error: Atoms would overlap, please try again!" << endl;
					exit(1);
				}
			}
			
			cout << "Atom " << j + 1 << " has the following values assigned:" << endl;
			cout << "Color" << j + 1 << " is      " << Atom[j].c << endl;
			cout << "Radius" << j + 1 << " is     " << Atom[j].r << endl;
			cout << "x Pos." << j + 1 << " is     " << Atom[j].x << endl;
			cout << "y Pos." << j + 1 << " is     " << Atom[j].y << endl;
			cout << "vx" << j + 1 << " is         " << Atom[j].vx << endl;
			cout << "vy" << j + 1 << " is         " << Atom[j].vy << endl;
		}
	}
	else { cout << "Error: Please give a valid Argument!"; }
}

//**********************************************************
// Function "Draw"
// 
// Input: number of Atoms and values of these Atoms
// 
// Output: none
// 
// The draw function draws each individual "Frame" of the animation
// by first drawing a blank background and then drawing each individual Atom
// at its respective position. All of this is updated as one "Frame". 
//**********************************************************

void draw(int n, Atom Atom[]) {
	fillRectangle(0, 0, W, H, 0xFFFFFF);
	
	for (int j = 0; j < n; j++) {
		fillEllipse(Atom[j].x - Atom[j].r, Atom[j].y - Atom[j].r, 2 * Atom[j].r, 2 * Atom[j].r, Atom[j].c);
	}
	
	flush();
}

//**********************************************************
// Funtion "Update"
// 
// Input:number of Atoms and Values of Atoms
// 
// Output: none
// 
// The "Update" Function determines the position of every Atom
// by calculation their position through their velocities in x and y.
// It also handles Atom bouncing from Walls and later also themselves.
//**********************************************************

void update(int n, Atom Atom[]) {
	
	double Vx = 0;//maybe in for deklarieren?
	double Vy = 0;
	
	for (int j = 0; j < n; j++) {
		
		Atom[j].x += Atom[j].vx;
		Atom[j].y += Atom[j].vy;
		
		//checks for collisions between atoms and walls
		
		if (Atom[j].x >= W - Atom[j].r)
		{
			Atom[j].vx = -Atom[j].vx;
			Atom[j].x = W - Atom[j].r;
		}
		if (Atom[j].x <= Atom[j].r)
		{
			Atom[j].vx = -Atom[j].vx;
			Atom[j].x = Atom[j].r;
		}
		if (Atom[j].y >= H - Atom[j].r)
		{
			Atom[j].vy = -Atom[j].vy;
			Atom[j].y = H - Atom[j].r;
		}
		if (Atom[j].y <= Atom[j].r)
		{
			Atom[j].vy = -Atom[j].vy;
			Atom[j].y = Atom[j].r;
		}
		
		//checks for collisions between different atoms
		for (int l = 0; l <= j; l++) {
			
			int dx = Atom[j].x - Atom[l].x;
			int dy = Atom[j].y - Atom[l].y;
			int rsum = Atom[j].r + Atom[l].r;
			
			if (sqrt(pow(dx,2)+ pow(dy,2)) <= rsum && j != l)
			{
				
				double alpha = atan2(dy,dx);
				int dx1 = cos(alpha) * rsum;
				int dy1 = sin(alpha) * rsum;
				
				Atom[j].x += dx1 - dx;
				Atom[j].y += dy1 - dy;
				
				double beta = 3.1415926 - alpha;
				
				double a;
				double r;
				double vx1;
				double vy1;
				
				toPolar(Atom[j].vx, Atom[j].vy, r, a);
				a - beta;
				toCartesian(r, a, vx1, vy1);
				
				Atom[j].vx = vx1;
				Atom[j].vy = vy1;
				
				toPolar(Atom[l].vx, Atom[l].vy, r, a);
				a - beta;
				toCartesian(r, a, vx1, vy1);
				
				Atom[l].vx = vx1;
				Atom[l].vy = vy1;
				
				Vx = (pow(Atom[l].r, 2) * Atom[l].vx + pow(Atom[j].r, 2) * Atom[j].vx) / (pow(Atom[j].r, 2) + pow(Atom[l].r, 2));
				Vy = (pow(Atom[l].r, 2) * Atom[l].vy + pow(Atom[j].r, 2) * Atom[j].vy) / (pow(Atom[j].r, 2) + pow(Atom[l].r, 2));
				
				Atom[j].vx = 2 * Vx - Atom[j].vx;
				Atom[j].vy = 2 * Vy - Atom[j].vy;
				
				Atom[l].vx = 2 * Vx - Atom[l].vx;
				Atom[l].vy = 2 * Vy - Atom[l].vy;
				
				cout << "Kollision" << endl;//for debugging
			}
		}
	}
}


int main(int argc, const char* argv[])
{
	beginDrawing(W, H, "Atoms", 0xFFFFFF, false);
	int n = number(argc, argv);
	Atom* atoms = new Atom[n];
	init(n, atoms, argc, argv);
	draw(n, atoms);
	cout << "Press <ENTER> to continue..." << endl;
	string s; getline(cin, s);
	for (int i = 0; i < F; i++)
	{
		update(n, atoms);
		draw(n, atoms);
		Sleep(S);
	}
	delete[] atoms;
	cout << "Close window to exit..." << endl;
	endDrawing();
}
		\end{lstlisting}
	
	
	
	
	
	
	
	
	
	
	
	
		\subsection{Aufgabe 47}
			Wir betrachten die Intervalle $(a,b)$ und $(c,d)$ mit $a<b$ und $c<d$
			z.z.: $(a,b)$ Gleichmächtig $(c,d)$, also $(a,b)~(c,d)$ 
			
			Um zu zeigen, dass zwei Mengen gleichmächtig sind gilt es, eine Bijektion zwischen diesen zu finden.
			Wir wählen:
			\begin{displaymath}
				f(x)=(x-a) \cdot \frac{d-c}{b-a}+c
			\end{displaymath}
			\begin{figure}[h]
				\centering
				\includegraphics[width=5cm]{Graph1.png}
				\caption{Skizze zu $f(x)$}
				\label{fig:Bild}
			\end{figure}
			Da diese Funktionj bijektiv und Abgeschlossen ist, gilt $(a,b)~(c,d)$
		
		\subsection{Aufgabe 48}
			$X:={f: \mathbb{N} \rightarrow {0,1}}$
			Ist $X$ abzählbar?
			
			Behauptung: $X$	ist überabzählbar.
			
			Begründung:
				
			Man ziehe die Potenzmenge $P(\mathbb{N})$ heran. Diese Potenzmenge ist überabzählbar. Wir bilden nehmen nun je ein Element von $P(\mathbb{N})$ (also eine Menge), diese bel. Menge nennen wir $N$,es gilt $N\subseteq \mathbb{N}$.
			Wir können $N$ nun auf X bijektiv abbilden, weil es genau $\vert P(\mathbb{N})\vert$ viele Möglichkeiten für f gibt.
			Damit ist X überabzählbar.
			
		\subsection{Aufgabe 49}
			Grenzwert bestimmen
			\begin{displaymath}
				\lim \limits_{n \to \infty}	\frac{\frac{7n^k}{n^3}+\frac{n}{n^3}}{2\cdot \frac{n^3}{n^3}+9\cdot\frac{n^2}{n^3}+\frac{1}{n^3}}	
				=\lim \limits_{n \to \infty}	\frac{\frac{7n^k}{n^3}+\frac{1}{n^2}}{2+9\cdot\frac{1}{n}+\frac{1}{n^3}}
				=\lim \limits_{n \to \infty}\frac{\frac{7n^k}{n^3}+0}{2+0+0}
				=\lim \limits_{n \to \infty}\frac{2}{7}\cdot\frac{n^k}{n^3}
			\end{displaymath}	
			Obige Umformung gilt für alle $k \leq 3$.
			
			Für $k<3$ konvergiert die Folge gegen $0$.
			
			Für $k=3$ konvergiert die Folge gegen $\frac{2}{7}$
			
			Für $k>3$ ist die Folge divergent.
			
		\subsection{Aufgabe 50}
			sei $a_n$ eine nichtnegative Folge mit $a_n \rightarrow a$
		
			z.z.: $\sqrt{a_n} \rightarrow \sqrt{a}$
			
			Fall 1: $a=0$
			\begin{displaymath}
				\exists n_0 \in \mathbb{N} \forall n \geq n_0 :\vert a_n\vert < \varepsilon^2 \Rightarrow \vert\sqrt{a_n}<\sqrt{\varepsilon^2}=\varepsilon
			\end{displaymath}
			Fall 2: $a>0$
			\begin{displaymath}
				\vert a_n-a\vert<\varepsilon
			\end{displaymath}
			\begin{displaymath}
				\vert\sqrt{a_n}-\sqrt{a}\vert=\left\vert \sqrt{a_n}-\sqrt{a}\cdot\frac{\sqrt{a_n}+\sqrt{a}}{\sqrt{a_n}+\sqrt{a}} \right\vert=\frac{\vert a_n-a\vert}{\vert\sqrt{a_n}+\sqrt{a}\vert}
			\end{displaymath}
			Aufgrund der Nichtnegativität von $a_n$ und der Eigenschaften der Wurzel bleibt der Nenner positiv.
			\begin{displaymath}
				\frac{\vert a_n-a\vert}{\vert\sqrt{a_n}+\sqrt{a}\vert}<\frac{\sqrt{a}\cdot\varepsilon}{\sqrt{a}}=\varepsilon
			\end{displaymath}
		
		\subsection{Aufgabe 51}
			sei $a_n \rightarrow a$
			$(a_n)$ konvergent $\Rightarrow (a_n)$ beschränkt, d.h. $\exists M\geq0 \forall n\in\mathbb{N}:\vert a_n\vert\leq M$ und daher auch $a\leq M$und $\vert a_n-a\vert\leq \vert a_n\vert+\vert a \vert \leq 2\cdot M$
			
			sei $\varepsilon>0$. Es gibt (weil $a_n \rightarrow a$) ein $n_0 \in\mathbb{N}$ so dass $\vert a_n-a\vert<\varepsilon$ für alle $n\geq n_0$
			
			\begin{displaymath}
				\begin{split}
				\Rightarrow &\left\vert \frac{a_1+...+a_n}{n}-a \right\vert = \left\vert \frac{a_1+...+a_n}{n}-\frac{n\cdot a}{n} \right\vert\leq \sum\limits_{j=1 \to n}\frac{\vert a_j-a\vert}{n}=\sum\limits_{j=1 \to n_0}\frac{\vert a_j-a\vert}{n}+\sum\limits_{j=n_0+1 \to n}\frac{\vert a_j-a\vert}{n}\\
				&\\
				&\leq\frac{2\cdot M\cdot n_n}{n}+\frac{\varepsilon}{n}\cdot (n-n_0)\leq \frac{2\cdot M\cdot n_n}{n}+\varepsilon \leq 2\varepsilon  n\geq max \left\{ n_0,\frac{2\cdot M\cdot n_n}{n} \right\}
				\end{split}
			\end{displaymath}
\end{document}